<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academia 4.3.1">
  <meta name="generator" content="Hugo 0.101.0" />

  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="Introduction Hi, I&rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Lately I&rsquo;ve been doing some research into networking game physics simulations via deterministic lockstep methods.
The basic idea is that instead of synchronizing the state of physics objects directly by sending the positions, orientations, velocities etc. over the network, one could synchronize the simulation implicitly by sending just the player inputs.
This is a very attractive synchronization strategy because the amount of network traffic depends on the size of the player inputs instead of the amount of physics state in the world.">

  
  <link rel="alternate" hreflang="en-us" href="https://gafferongames.com/post/floating_point_determinism/">

  


  

  
  
  
  <meta name="theme-color" content="#3f51b5">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academiaons/1.8.6/css/academiaons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    

    

  

  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Open+Sans|Roboto+Mono&display=swap">
  

  
  
  
  <link rel="stylesheet" href="/css/academia.min.88bfd34630258dde91b90e40ca4fc6a8.css">

  

  
  
  

  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://gafferongames.com/post/floating_point_determinism/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@gafferongames">
  <meta property="twitter:creator" content="@gafferongames">
  
  <meta property="og:site_name" content="Gaffer On Games">
  <meta property="og:url" content="https://gafferongames.com/post/floating_point_determinism/">
  <meta property="og:title" content="Floating Point Determinism | Gaffer On Games">
  <meta property="og:description" content="Introduction Hi, I&rsquo;m Glenn Fiedler and welcome to Networking for Game Programmers.
Lately I&rsquo;ve been doing some research into networking game physics simulations via deterministic lockstep methods.
The basic idea is that instead of synchronizing the state of physics objects directly by sending the positions, orientations, velocities etc. over the network, one could synchronize the simulation implicitly by sending just the player inputs.
This is a very attractive synchronization strategy because the amount of network traffic depends on the size of the player inputs instead of the amount of physics state in the world."><meta property="og:image" content="https://gafferongames.com/img/icon-192.png">
  <meta property="twitter:image" content="https://gafferongames.com/img/icon-192.png"><meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2010-02-24T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2010-02-24T00:00:00&#43;00:00">
  

  


  





  <title>Floating Point Determinism | Gaffer On Games</title>

</head>


<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  
<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Gaffer On Games</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation"><span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav ml-auto">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Articles</span></a>
        </li>

        
        

      

        

        

        

        

      </ul>

    </div>
  </div>
</nav>


  <article class="article py-5" itemscope itemtype="http://schema.org/Article">

  












    

    
    
    
    <div class="article-container py-3">
      <h1 itemprop="name">Floating Point Determinism</h1>

      

      
      



<meta content="2010-02-24 00:00:00 &#43;0000 UTC" itemprop="datePublished">
<meta content="2010-02-24 00:00:00 &#43;0000 UTC" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    <time>Feb 24, 2010</time>
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    16 min read
  </span>
  

  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder"></i>
    <a href="/categories/game-networking/">Game Networking</a></span>
  

  
    

  

</div>

      














      
      
    </div>
  </div>
</div>

  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      <h2 id="introduction">Introduction</h2>
<p>Hi, I&rsquo;m <a href="https://gafferongames.com">Glenn Fiedler</a> and welcome to <a href="/categories/game-networking/"><strong>Networking for Game Programmers</strong></a>.</p>
<p>Lately I&rsquo;ve been doing some research into networking game physics simulations via deterministic lockstep methods.</p>
<p>The basic idea is that instead of synchronizing the state of physics objects directly by sending the positions, orientations, velocities etc. over the network, one could synchronize the simulation <em>implicitly</em> by sending just the player inputs.</p>
<p>This is a very attractive synchronization strategy because the amount of network traffic depends on the size of the player inputs instead of the amount of physics state in the world. In fact, this strategy has been used for many years in RTS games for precisely this reason; with thousands and thousands of units on the map, they simply have too much state to send over the network.</p>
<p>Perhaps you have a complex physics simulation with lots of rigid body state, or a cloth or soft body simulation which needs to stay perfectly in sync across two machines because it is gameplay affecting, but you cannot afford to send all the state. It is clear that the only possible solution in this situation is to attempt a deterministic networking strategy.</p>
<p>But we run into a problem. Physics simulations use floating point calculations, and for one reason or another it is considered <em>very difficult</em> to get exactly the same result from floating point calculations on two different machines. People even report different results on the same machine from run to run, and between debug and release builds. Other folks say that AMDs give different results to Intel machines, and that SSE results are different from x87. What exactly is going on? Are floating point calculations deterministic or not?</p>
<p>Unfortunately, the answer is not a simple &ldquo;yes&rdquo; or &ldquo;no&rdquo; but &ldquo;yes, if&hellip;&rdquo;</p>
<p>Here is what I have discovered so far:</p>
<ul>
<li>
<p>If your physics simulation is itself deterministic, with a bit of work you should be able to get it to play back a replay of recorded inputs on the same machine and get the exact same result.</p>
</li>
<li>
<p>It is possible to get deterministic results for floating calculations across multiple computers provided you use an executable built with the same compiler, run on machines with the same architecture, and perform some platform-specific tricks.</p>
</li>
<li>
<p>It is incredibly naive to write arbitrary floating point code in C or C++ and expect it to give exactly the same result across different compilers or architectures, or even the same results across debug and release builds.</p>
</li>
<li>
<p>However with a good deal of work you <u>may</u> be able to <a href="http://www.yosefk.com/blog/consistency-how-to-defeat-the-purpose-of-ieee-floating-point.html">coax</a> exactly the same floating point results out of different compilers or different machine architectures by using your compilers &ldquo;strict&rdquo; IEEE 754 compliant mode and restricting the set of floating point operations you use. This typically results in significantly lower floating point performance.</p>
</li>
</ul>
<p>If you would like to debate these points or add your own nuance, please <a href="/contact">contact</a> me! I consider this question by no means settled and am very interested in other peoples experiences with deterministic floating point simulations and exactly reproducible floating point calculations. Please contact me especially if you have managed to get binary exact results across different architectures and compilers in real world situations.</p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<p><u>Here are the resources I have discovered in my search so far&hellip;</u></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>The technology we license to various customers is based on determinism of floating point (in 64-bit mode, even) and has worked that way since the year 2000.
<p>As long as you stick to a single compiler, and a single CPU instruction set, it is possible to make floating point fully deterministic. The specifics vary by platform (i e, different between x86, x64 and PPC).</p>
<p>You have to make sure that the internal precision is set to 64 bits (not 80, because only Intel implements that), and that the rounding mode is consistent. Furthermore, you have to check this after calls to external DLLs, because many DLLs (Direct3D, printer drivers, sound libraries, etc) will change the precision or rounding mode without setting it back.</p>
<p>The ISA is IEEE compliant. If your x87 implementation isn&rsquo;t IEEE, it&rsquo;s not x87.</p>
<p>Also, you can&rsquo;t use SSE or SSE2 for floating point, because it&rsquo;s too under-specified to be deterministic.</blockquote></p>
<p><b>Jon Watte, GameDev.net forums</b>
<a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=499435"><a href="http://www.gamedev.net/community/forums/topic.asp?topic_id=499435">http://www.gamedev.net/community/forums/topic.asp?topic_id=499435</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>I work at Gas Powered Games and i can tell you first hand that floating point math is deterministic. You just need the same instruction set and compiler and of course the user's processor adheres to the IEEE754 standard, which includes all of our PC and 360 customers. The engine that runs DemiGod, Supreme Commander 1 and 2 rely upon the IEEE754 standard. Not to mention probably all other RTS peer to peer games in the market. As soon as you have a peer to peer network game where each client broadcasts what command they are doing on what 'tick' number and rely on the client computer to figure out the simulation/physical details your going to rely on the determinism of the floating point processor.
<p>At app startup time we call:</p>
<pre><code>_controlfp(_PC_24, _MCW_PC)
_controlfp(_RC_NEAR, _MCW_RC)
</code></pre>
<p>Also, every tick we assert that these fpu settings are still set:</p>
<pre><code>gpAssert( (_controlfp(0, 0) &amp;amp; _MCW_PC) == _PC_24 );
gpAssert( (_controlfp(0, 0) &amp;amp; _MCW_RC) == _RC_NEAR );
</code></pre>
<p>There are some MS API functions that can change the fpu model on you so you need to manually enforce the fpu mode after those calls to ensure the fpu stays the same across machines. The assert is there to catch if anyone has buggered the fpu mode.</p>
<p>FYI We have the compiler floating point model set to Fast /fp:fast ( but its not a requirement )</p>
<p>We have never had a problem with the IEEE standard across any PC cpu AMD and Intel with this approach. None of our SupCom or Demigod customers have had problems with their machines either, and we are talking over 1 million customers here (supcom1 + expansion pack). We would have heard if there was a problem with the fpu not having the same results as replays or multiplayer mode wouldn&rsquo;t work at all.</p>
<p>We did however have problems when using some physics APIs because their code did not have determinism or reproducibility in mind. For example some physics APIS have solvers that take X number of iterations when solving where X can be lower with faster CPUs.</blockquote></p>
<p><b>Elijah, Gas Powered Games</b><br>
<a href="http://www.box2d.org/forum/viewtopic.php?f=3&amp;t=1800"><a href="http://www.box2d.org/forum/viewtopic.php?f=3&amp;amp;t=1800">http://www.box2d.org/forum/viewtopic.php?f=3&amp;amp;t=1800</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>If you store replays as controller inputs, they cannot be played back on machines with different CPU architectures, compilers, or optimization settings. In MotoGP, this meant we could not share saved replays between Xbox and PC. It also meant that if we saved a replay from a debug build of the game, it would not work in release builds, or vice versa. This is not always a problem (we never shipped debug builds, after all), but if we ever released a patch, we had to build it using the exact same compiler as the original game. If the compiler had been updated since our original release, and we built a patch using the newer compiler, this could change things around enough that replays saved by the original game would no longer play back correctly.
<p>This is madness! Why don&rsquo;t we make all hardware work the same? Well, we could, if we didn&rsquo;t care about performance. We could say &ldquo;hey Mr. Hardware Guy, forget about your crazy fused multiply-add instructions and just give us a basic IEEE implementation&rdquo;, and &ldquo;hey Compiler Dude, please don&rsquo;t bother trying to optimize our code&rdquo;. That way our programs would run consistently slowly everywhere :-)</blockquote></p>
<p><b>Shawn Hargreaves, MSDN Blog</b>
<a href="http://blogs.msdn.com/shawnhar/archive/2009/03/25/is-floating-point-math-deterministic.aspx"><a href="http://blogs.msdn.com/shawnhar/archive/2009/03/25/is-floating-point-math-deterministic.aspx">http://blogs.msdn.com/shawnhar/archive/2009/03/25/is-floating-point-math-deterministic.aspx</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>"Battlezone 2 used a lockstep networking model requiring absolutely identical results on every client, down to the least-significant bit of the mantissa, or the simulations would start to diverge. While this was difficult to achieve, it meant we only needed to send user input across the network; all other game state could be computed locally. During development, we discovered that AMD and Intel processors produced slightly different results for trancendental functions (sin, cos, tan, and their inverses), so we had to wrap them in non-optimized function calls to force the compiler to leave them at single-precision. That was enough to make AMD and Intel processors consistent, but it was definitely a learning experience.</blockquote>
<p><b>Ken Miller, Pandemic Studios</b><br>
<a href="http://www.box2d.org/forum/viewtopic.php?f=4&amp;t=175"><a href="http://www.box2d.org/forum/viewtopic.php?f=4&amp;amp;t=175">http://www.box2d.org/forum/viewtopic.php?f=4&amp;amp;t=175</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>... In FSW1 when desync is detected in player would be instantly killed by "magic sniper". :) All that stuff was fixed in FSW2. We just ran precise FP and used Havok FPU libs instead SIMD on PC. Also integer modulo is problem too because C++ standard says it's "implementation defined" (in case when multiple compilers/platforms are used). In general I liked tools for lockstep we developed, finding desyncs in code on FSW2 was trivial.</blockquote>
<p><b>Branimir Karadžić, Pandemic Studios</b>
<a href="http://www.google.com/buzz/100111796601236342885/8hDZ655S6x3/Floating-Point-Determinism-Gaffer-on-Games">http://www.google.com/buzz/100111796601236342885/8hDZ655S6x3/Floating-Point-Determinism-Gaffer-on-Games</a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote> I know three main sources of floating point inconsistency pain:
<p>Algebraic compiler optimizations
“Complex” instructions like multiply-accumulate or sine
x86-specific pain not available on any other platform; not that ~100% of non-embedded devices is a small market share for a pain.</p>
<p>The good news is that most pain comes from item 3 which can be more or less solved automatically. For the purpose of decision making (”should we invest energy into FP consistency or is it futile?”), I’d say that it’s not futile and if you can cite actual benefits you’d get from consistency, then it’s worth the (continuous) effort.</p>
<p>Summary: use SSE2 or SSE, and if you can’t, configure the FP CSR to use 64b intermediates and avoid 32b floats. Even the latter solution works passably in practice, as long as everybody is aware of it.</blockquote></p>
<p><b>Yossi Kreinin, Personal Blog</b><br>
<a href="http://www.yosefk.com/blog/consistency-how-to-defeat-the-purpose-of-ieee-floating-point.html"><a href="http://www.yosefk.com/blog/consistency-how-to-defeat-the-purpose-of-ieee-floating-point.html">http://www.yosefk.com/blog/consistency-how-to-defeat-the-purpose-of-ieee-floating-point.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>The short answer is that FP calculations are entirely deterministic, as per the IEEE Floating Point Standard, but that doesn't mean they're entirely reproducible across machines, compilers, OS's, etc.
<p>The long answer to these questions and more can be found in what is probably the best reference on floating point, David Goldberg&rsquo;s What Every Computer Scientist Should Know About Floating Point Arithmetic. Skip to the section on the IEEE standard for the key details.</p>
<p>Finally, if you are doing the same sequence of floating point calculations on the same initial inputs, then things should be replayable exactly just fine. The exact sequence can change depending on your compiler/os/standard library, so you might get some small errors this way.</p>
<p>Where you usually run into problems in floating point is if you have a numerically unstable method and you start with FP inputs that are approximately the same but not quite. If your method&rsquo;s stable, you should be able to guarantee reproducibility within some tolerance. If you want more detail than this, then take a look at Goldberg&rsquo;s FP article linked above or pick up an intro text on numerical analysis.</blockquote></p>
<p><b>Todd Gamblin, Stack Overflow</b>
<a href="http://stackoverflow.com/questions/968435/what-could-cause-a-deterministic-process-to-generate-floating-point-errors"><a href="http://stackoverflow.com/questions/968435/what-could-cause-a-deterministic-process-to-generate-floating-point-errors">http://stackoverflow.com/questions/968435/what-could-cause-a-deterministic-process-to-generate-floating-point-errors</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>The C++ standard does not specify a binary representation for the floating-point types float, double and long double. Although not required by the standard, the implementation of floating point arithmetic used by most C++ compilers conforms to a standard, IEEE 754-1985, at least for types float and double. This is directly related to the fact that the floating point units of modern CPUs also support this standard. The IEEE 754 standard specifies the binary format for floating point numbers, as well as the semantics for floating point operations. Nevertheless, the degree to which the various compilers implement all the features of IEEE 754 varies. This creates various pitfalls for anyone writing portable floating-point code in C++.</blockquote>
<p><b>Günter Obiltschnig, Cross-Platform Issues with Floating-Point arithmetics in C++</b>
<a href="http://www.appinf.com/download/FPIssues.pdf"><a href="http://www.appinf.com/download/FPIssues.pdf">http://www.appinf.com/download/FPIssues.pdf</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Floating-point computations are strongly dependent on the FPU hardware implementation, the compiler and its optimizations, and the system mathematical library (libm). Experiments are usually reproducible only on the same machine with the same system library and the same compiler using the same options.</blockquote>
<p><b>STREFLOP Library</b>
<a href="http://nicolas.brodu.numerimoire.net/en/programmation/streflop/index.html"><a href="http://nicolas.brodu.numerimoire.net/en/programmation/streflop/index.html">http://nicolas.brodu.numerimoire.net/en/programmation/streflop/index.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Floating Point (FP) Programming Objectives:
<p>• <b>Accuracy</b> - Produce results that are “close” to the correct value</p>
<p>• <b>Reproducibility</b> - Produce consistent results from one run to the next. From one set of build options to another. From one compiler to another. From one platform to another.</p>
<p>• <b>Performance</b> – Produce the most efficient code possible.</p>
<p>These options usually conflict! Judicious use of compiler options lets you control the tradeoffs.</blockquote></p>
<p><b>Intel C++ Compiler: Floating Point Consistency</b>
<a href="http://www.nccs.nasa.gov/images/FloatingPoint%5Fconsistency.pdf"><a href="http://www.nccs.nasa.gov/images/FloatingPoint%5Fconsistency.pdf">http://www.nccs.nasa.gov/images/FloatingPoint%5Fconsistency.pdf</a></a>.</p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>If strict reproducibility and consistency are important do not change the floating point environment without also using either fp-model strict (Linux or Mac OS*) or /fp:strict (Windows*) option or pragma fenv_access.</blockquote>
<p><b>Intel C++ Compiler Manual</b>
<a href="http://cache-www.intel.com/cd/00/00/34/76/347605_347605.pdf">http://cache-www.intel.com/cd/00/00/34/76/347605_347605.pdf</a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Under the fp:strict mode, the compiler never performs any optimizations that perturb the accuracy of floating-point computations. The compiler will always round correctly at assignments, typecasts and function calls, and intermediate rounding will be consistently performed at the same precision as the FPU registers. Floating-point exception semantics and FPU environment sensitivity are enabled by default. Certain optimizations, such as contractions, are disabled because the compiler cannot guarantee correctness in every case.</blockquote>
<p><b>Microsoft Visual C++ Floating-Point Optimization</b>
<a href="http://msdn.microsoft.com/en-us/library/aa289157(VS.71).aspx#floapoint_topic4"><a href="http://msdn.microsoft.com/en-us/library/aa289157(VS.71).aspx#floapoint_topic4">http://msdn.microsoft.com/en-us/library/aa289157(VS.71).aspx#floapoint_topic4</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Please note that the results of floating point calculations will likely not be exactly the same between PowerPC and Intel, because the PowerPC scalar and vector FPU cores are designed around a fused multiply add operation. The Intel chips have separate multiplier and adder, meaning that those operations must be done separately. This means that for some steps in a calculation, the Intel CPU may incur an extra rounding step, which may introduce 1/2 ulp errors at the multiplication stage in the calculation.</blockquote>
<p><b>Apple Developer Support</b>
<a href="http://developer.apple.com/hardwaredrivers/ve/sse.html"><a href="http://developer.apple.com/hardwaredrivers/ve/sse.html">http://developer.apple.com/hardwaredrivers/ve/sse.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>For all of the instructions that are IEEE operations (*,+,-,/,sqrt, compares, regardless of whether they are SSE or x87), they will produce the same results across platforms with the same control settings (same precision control and rounding modes, flush to zero, etc.) and inputs.  This is true for both 32-bit and 64-bit processors... On the x87 side, the transcendental instructions like, fsin, fcos, etc. could produce slightly different answers across implementations. They are specified with a relative error that is guaranteed, but not bit-for-bit accuracy.</blockquote>
<p><b>Intel Software Network Support</b>
<a href="http://software.intel.com/en-us/forums/showthread.php?t=48339"><a href="http://software.intel.com/en-us/forums/showthread.php?t=48339">http://software.intel.com/en-us/forums/showthread.php?t=48339</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>I'm concerned about the possible differences between hardware implementations of IEEE-754. I already know about the problem of programming languages introducing subtle differences between what is written in the source code and what is actually executed at the assembly level. [Mon08] Now, I'm interested in differences between, say, Intel/SSE and PowerPC at the level of individual instructions.</blockquote>
<p><b>D. Monniaux on IEEE 754 mailing list</b>
<a href="http://grouper.ieee.org/groups/754/email/msg03864.html"><a href="http://grouper.ieee.org/groups/754/email/msg03864.html">http://grouper.ieee.org/groups/754/email/msg03864.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>One must ... avoid the non-754 instructions that are becoming more prevalent for inverse and inverse sqrt that don't round correctly or even consistently from one implementation to another, as well as the x87 transcendental operations which are necessarily implemented differently by AMD and Intel.</blockquote>
<p><b>David Hough on 754 IEEE mailing list</b>
<a href="http://grouper.ieee.org/groups/754/email/msg03867.html"><a href="http://grouper.ieee.org/groups/754/email/msg03867.html">http://grouper.ieee.org/groups/754/email/msg03867.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Yes, getting reproducible results IS possible.  But you CAN'T do it without defining a programming methodology intended to deliver that property.  And that has FAR more drastic consequences than any of its proponents admit - in particular, it is effectively incompatible with most forms of parallelism.</blockquote>
<p><b>Nick Maclaren on 754 IEEE mailing list</b>
<a href="http://grouper.ieee.org/groups/754/email/msg03872.html"><a href="http://grouper.ieee.org/groups/754/email/msg03872.html">http://grouper.ieee.org/groups/754/email/msg03872.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>If we are talking practicabilities, then things are very different, and expecting repeatable results in real programs is crying for the moon. But we have been there before, and let's not go there again.</blockquote>
<p><b>Nick Maclaren on 754 IEEE mailing list</b>
<a href="http://grouper.ieee.org/groups/754/email/msg03862.html"><a href="http://grouper.ieee.org/groups/754/email/msg03862.html">http://grouper.ieee.org/groups/754/email/msg03862.html</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>The IEEE 754-1985 allowed many variations in implementations (such as the encoding of some values and the detection of certain exceptions). IEEE 754-2008 has tightened up many of these, but a few variations still remain (especially for binary formats). The reproducibility clause recommends that language standards should provide a means to write reproducible programs (i.e., programs that will produce the same result in all implementations of a language), and describes what needs to be done to achieve reproducible results.</blockquote>
<p><b>Wikipedia Page on IEEE 754-2008 standard</b>
<a><a href="http://en.wikipedia.org/wiki/IEEE_754-2008#Reproducibility">http://en.wikipedia.org/wiki/IEEE_754-2008#Reproducibility</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>If one wants semantics almost exactly faithful to strict IEEE-754 single or double precision computations in round-to-nearest mode, including with respect to overflow and underflow conditions, one can use, at the same time, limitation of precision and options and programming style that force operands to be systematically written to memory between floating-point operations. This incurs some performance loss; furthermore, there will still be slight discrepancy due to double rounding on underflow.
<p>A simpler solution for current personal computers is simply to force the compiler to use the SSE unit for computations on IEEE-754 types; however, most embedded systems using IA32 microprocessors or microcontrollers do not use processors equipped with this unit.</blockquote></p>
<p><b>David Monniaux, The pitfalls of verifying floating-point computations</b>
<a href="http://hal.archives-ouvertes.fr/docs/00/28/14/29/PDF/floating-point-article.pdf"><a href="http://hal.archives-ouvertes.fr/docs/00/28/14/29/PDF/floating-point-article.pdf">http://hal.archives-ouvertes.fr/docs/00/28/14/29/PDF/floating-point-article.pdf</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>6. REPRODUCIBILITY
<p>Even under the 1985 version of IEEE-754, if two implementations of the standard executed an operation on the same data, under the same rounding mode and default exception handling, the result of the operation would be identical. The new standard tries to go further to describe when a program will produce identical floating point results on different implementations. The operations described in the standard are all reproducible operations.</p>
<p>The recommended operations, such as library functions or reduction operators are not reproducible, because they are not required in all implementations. Likewise dependence on the underflow and inexact flags is not reproducible because two different methods of treating underflow are allowed to preserve conformance between IEEE-754(1985) and IEEE-754(2008). The rounding modes are reproducible attributes. Optional attributes are not reproducible.</p>
<p>The use of value-changing optimizations is to be avoided for reproducibility. This includes use of the associative and disributative laws, and automatic generation of fused multiply-add operations when the programmer did not explicitly use that operator.</blockquote></p>
<p><b>Peter Markstein, The New IEEE Standard for Floating Point Arithmetic</b>
<a href="http://drops.dagstuhl.de/opus/volltexte/2008/1448/pdf/08021.MarksteinPeter.ExtAbstract.1448.pdf"><a href="http://drops.dagstuhl.de/opus/volltexte/2008/1448/pdf/08021.MarksteinPeter.ExtAbstract.1448.pdf">http://drops.dagstuhl.de/opus/volltexte/2008/1448/pdf/08021.MarksteinPeter.ExtAbstract.1448.pdf</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<blockquote>Unfortunately, the IEEE standard does not guarantee that the same program will deliver identical results on all conforming systems. Most programs will actually produce different results on different systems for a variety of reasons. For one, most programs involve the conversion of numbers between decimal and binary formats, and the IEEE standard does not completely specify the accuracy with which such conversions must be performed. For another, many programs use elementary functions supplied by a system library, and the standard doesn't specify these functions at all. Of course, most programmers know that these features lie beyond the scope of the IEEE standard.
<p>Many programmers may not realize that even a program that uses only the numeric formats and operations prescribed by the IEEE standard can compute different results on different systems. In fact, the authors of the standard intended to allow different implementations to obtain different results. Their intent is evident in the definition of the term destination in the IEEE 754 standard: &ldquo;A destination may be either explicitly designated by the user or implicitly supplied by the system (for example, intermediate results in subexpressions or arguments for procedures). Some languages place the results of intermediate calculations in destinations beyond the user&rsquo;s control. Nonetheless, this standard defines the result of an operation in terms of that destination&rsquo;s format and the operands&rsquo; values.&rdquo; (IEEE 754-1985, p. 7) In other words, the IEEE standard requires that each result be rounded correctly to the precision of the destination into which it will be placed, but the standard does not require that the precision of that destination be determined by a user&rsquo;s program. Thus, different systems may deliver their results to destinations with different precisions, causing the same program to produce different results (sometimes dramatically so), even though those systems all conform to the standard.</blockquote></p>
<p><b>Differences Among IEEE 754 Implementations</b>
<a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#3098"><a href="http://docs.sun.com/source/806-3568/ncg_goldberg.html#3098">http://docs.sun.com/source/806-3568/ncg_goldberg.html#3098</a></a></p>
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<img style="border:0 initial initial;" title="half-spacer" src="/img/half-spacer.png" width="34" height="12" />
<hr>
<p><strong>Glenn Fiedler</strong> is the founder and CEO of <strong><a href="https://networknext.com">Network Next</a></strong>.<br><i>Network Next is fixing the internet for games by creating a marketplace for premium network transit.</i></p>

    </div>

    

<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/networking/">networking</a>
  
</div>



    
      








  
  
  





  
  
  
  
  <div class="media author-card" itemscope itemtype="http://schema.org/Person">
    

    <div class="media-body">
      <h5 class="card-title" itemprop="name"><a href="/authors/"></a></h5>
      
      
      <ul class="network-icon" aria-hidden="true">
        
      </ul>
    </div>
  </div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/what_every_programmer_needs_to_know_about_game_networking/">What Every Programmer Needs To Know About Game Networking</a></li>
          
          <li><a href="/post/reliability_ordering_and_congestion_avoidance_over_udp/">Reliability and Congestion Avoidance over UDP</a></li>
          
          <li><a href="/post/virtual_connection_over_udp/">Virtual Connection over UDP</a></li>
          
          <li><a href="/post/sending_and_receiving_packets/">Sending and Receiving Packets</a></li>
          
          <li><a href="/post/udp_vs_tcp/">UDP vs. TCP</a></li>
          
        </ul>
      </div>
      
    

    

    


  </div>
</article>

      

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js" integrity="sha256-aYTdUrn6Ow1DDgh5JTc3aDGnnju48y/1c8s1dgkYPQ8=" crossorigin="anonymous"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    

    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    <script src="/js/academia.min.b8df6754deca2dd84ba46243e6dcb3e3.js"></script>

    






  
  <div class="container">
    <footer class="site-footer">

  <div class="container">
    <div class="row">
      <div class="col-md-6">
        
        <p>
          Copyright © Glenn Fiedler, 2004 - 2020 
        </p>
      </div>
      <div class="col-md-6">
        <ul class="list-inline network-icon text-right">
          
          
          
          
          
          
          
          
          
          
          
          
          
          <li class="list-inline-item">
            <a href="https://twitter.com/Twitter" target="_blank" rel="noopener" title="DM Me"><i class="fab fa-twitter" aria-hidden="true"></i></a>
          </li>
          
        </ul>
      </div>
    </div>
  </div>
</footer>
  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
